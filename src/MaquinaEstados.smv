
---

```smv
-- blocks.smv
-- Máquina de Estados - Mundo dos Blocos com tamanhos variáveis
-- Compatível com o código Prolog fornecido

MODULE main

-- Cada bloco tem uma posição discreta:
-- 0..6  = posição inicial na mesa (slot à esquerda)
-- 7..10 = empilhado sobre outro bloco (on_x codificado)
CONSTANTS
  MAXLOC := 10;

VAR
  loc_a : 0..MAXLOC;
  loc_b : 0..MAXLOC;
  loc_c : 0..MAXLOC;
  loc_d : 0..MAXLOC;

  move : 0..20; -- código da ação escolhida

-- Larguras (size/2)
DEFINE
  SIZE_A := 1;
  SIZE_B := 1;
  SIZE_C := 2;
  SIZE_D := 2;
  TABLE_WIDTH := 7;

-- Códigos para representar "on"
DEFINE
  ON_A := 7;
  ON_B := 8;
  ON_C := 9;
  ON_D := 10;

-- Posição absoluta: se estiver sobre outro bloco, herda a posição do suporte
DEFINE
  abs_pos_a := case
    loc_a <= 6 : loc_a;
    loc_a = ON_B : abs_pos_b;
    loc_a = ON_C : abs_pos_c;
    loc_a = ON_D : abs_pos_d;
    TRUE : 0;
  esac;

  abs_pos_b := case
    loc_b <= 6 : loc_b;
    loc_b = ON_A : abs_pos_a;
    loc_b = ON_C : abs_pos_c;
    loc_b = ON_D : abs_pos_d;
    TRUE : 0;
  esac;

  abs_pos_c := case
    loc_c <= 6 : loc_c;
    loc_c = ON_A : abs_pos_a;
    loc_c = ON_B : abs_pos_b;
    loc_c = ON_D : abs_pos_d;
    TRUE : 0;
  esac;

  abs_pos_d := case
    loc_d <= 6 : loc_d;
    loc_d = ON_A : abs_pos_a;
    loc_d = ON_B : abs_pos_b;
    loc_d = ON_C : abs_pos_c;
    TRUE : 0;
  esac;

-- Um bloco está "clear" se nenhum outro está sobre ele
DEFINE
  clear_a := !(loc_b = ON_A | loc_c = ON_A | loc_d = ON_A);
  clear_b := !(loc_a = ON_B | loc_c = ON_B | loc_d = ON_B);
  clear_c := !(loc_a = ON_C | loc_b = ON_C | loc_d = ON_C);
  clear_d := !(loc_a = ON_D | loc_b = ON_D | loc_c = ON_D);

-- Pré-condições simplificadas para empilhamento
DEFINE
  can_move_a_on_b := clear_a & clear_b & (SIZE_A <= SIZE_B);
  can_move_a_on_c := clear_a & clear_c & (SIZE_A <= SIZE_C);
  can_move_a_on_d := clear_a & clear_d & (SIZE_A <= SIZE_D);

  can_move_b_on_a := clear_b & clear_a & (SIZE_B <= SIZE_A);
  can_move_b_on_c := clear_b & clear_c & (SIZE_B <= SIZE_C);
  can_move_b_on_d := clear_b & clear_d & (SIZE_B <= SIZE_D);

  can_move_c_on_a := clear_c & clear_a & (SIZE_C <= SIZE_A);
  can_move_c_on_b := clear_c & clear_b & (SIZE_C <= SIZE_B);
  can_move_c_on_d := clear_c & clear_d & (SIZE_C <= SIZE_D);

  can_move_d_on_a := clear_d & clear_a & (SIZE_D <= SIZE_A);
  can_move_d_on_b := clear_d & clear_b & (SIZE_D <= SIZE_B);
  can_move_d_on_c := clear_d & clear_c & (SIZE_D <= SIZE_C);

-- Estado inicial (exemplo: Situação 1)
INIT
  loc_a = 3 & loc_b = 4 & loc_c = 0 & loc_d = 5 & move = 0;

-- Transições: define como os blocos podem mudar de posição
TRANS
  case
    move = 1 : next(loc_a) = ON_C;   -- move a on c
    move = 2 : next(loc_b) = ON_A;   -- move b on a
    move = 3 : next(loc_d) = ON_B;   -- move d on b
    TRUE : next(loc_a) = loc_a;
  esac
  &
  case
    move = 1 : next(loc_b) = loc_b;
    move = 2 : next(loc_b) = loc_b;
    TRUE : next(loc_b) = loc_b;
  esac
  &
  case
    TRUE : next(loc_c) = loc_c;
  esac
  &
  case
    TRUE : next(loc_d) = loc_d;
  esac
  &
  TRUE : next(move) in {0,1,2,3};

-- Objetivo: Situação 1 (torre completa c–a–b–d)
-- pos(c,table(0)), pos(a,on(c)), pos(b,on(a)), pos(d,on(b))
DEFINE
  goal := (loc_c = 0) & (loc_a = ON_C) & (loc_b = ON_A) & (loc_d = ON_B);

-- Verifica se existe caminho que leva ao estado objetivo
CTLSPEC EF(goal)
