-- blocks_scenarios_fixed.smv
-- Máquina de Estados - Mundo dos Blocos com múltiplos cenários
-- Versão corrigida e compatível com NuSMV

MODULE main

CONSTANTS
  MAXLOC := 10;
  SCENARIO := 1;  -- <<< escolha aqui: 1, 2 ou 3

VAR
  loc_a : 0..MAXLOC;
  loc_b : 0..MAXLOC;
  loc_c : 0..MAXLOC;
  loc_d : 0..MAXLOC;
  move  : 0..3;  -- código da ação escolhida

DEFINE
  SIZE_A := 1;
  SIZE_B := 1;
  SIZE_C := 2;
  SIZE_D := 2;
  TABLE_WIDTH := 7;

  ON_A := 7;
  ON_B := 8;
  ON_C := 9;
  ON_D := 10;

-- posição absoluta: se estiver sobre outro bloco, herda a posição do suporte
DEFINE
  abs_pos_a := case
    loc_a <= 6 : loc_a;
    loc_a = ON_B : abs_pos_b;
    loc_a = ON_C : abs_pos_c;
    loc_a = ON_D : abs_pos_d;
    TRUE : 0;
  esac;

  abs_pos_b := case
    loc_b <= 6 : loc_b;
    loc_b = ON_A : abs_pos_a;
    loc_b = ON_C : abs_pos_c;
    loc_b = ON_D : abs_pos_d;
    TRUE : 0;
  esac;

  abs_pos_c := case
    loc_c <= 6 : loc_c;
    loc_c = ON_A : abs_pos_a;
    loc_c = ON_B : abs_pos_b;
    loc_c = ON_D : abs_pos_d;
    TRUE : 0;
  esac;

  abs_pos_d := case
    loc_d <= 6 : loc_d;
    loc_d = ON_A : abs_pos_a;
    loc_d = ON_B : abs_pos_b;
    loc_d = ON_C : abs_pos_c;
    TRUE : 0;
  esac;

-- um bloco está "clear" se nenhum outro está sobre ele
DEFINE
  clear_a := !(loc_b = ON_A | loc_c = ON_A | loc_d = ON_A);
  clear_b := !(loc_a = ON_B | loc_c = ON_B | loc_d = ON_B);
  clear_c := !(loc_a = ON_C | loc_b = ON_C | loc_d = ON_C);
  clear_d := !(loc_a = ON_D | loc_b = ON_D | loc_c = ON_D);

-- pré-condições simplificadas
DEFINE
  can_move_a_on_c := clear_a & clear_c & (SIZE_A <= SIZE_C);
  can_move_b_on_a := clear_b & clear_a & (SIZE_B <= SIZE_A);
  can_move_d_on_b := clear_d & clear_b & (SIZE_D <= SIZE_B);

-- inicialização de loc_* dependendo do cenário escolhido
ASSIGN
  init(loc_a) :=
    case
      SCENARIO = 1 : 3;
      SCENARIO = 2 : 1;
      SCENARIO = 3 : 0;
    esac;

  init(loc_b) :=
    case
      SCENARIO = 1 : 4;
      SCENARIO = 2 : 2;
      SCENARIO = 3 : 5;
    esac;

  init(loc_c) :=
    case
      SCENARIO = 1 : 0;
      SCENARIO = 2 : 3;
      SCENARIO = 3 : 1;
    esac;

  init(loc_d) :=
    case
      SCENARIO = 1 : 5;
      SCENARIO = 2 : 4;
      SCENARIO = 3 : 2;
    esac;

  init(move) := 0;

-- transições de estado
ASSIGN
  next(loc_a) :=
    case
      move = 1 & can_move_a_on_c : ON_C;
      TRUE : loc_a;
    esac;

  next(loc_b) :=
    case
      move = 2 & can_move_b_on_a : ON_A;
      TRUE : loc_b;
    esac;

  next(loc_c) :=
    case
      TRUE : loc_c;
    esac;

  next(loc_d) :=
    case
      move = 3 & can_move_d_on_b : ON_B;
      TRUE : loc_d;
    esac;

  next(move) :=
    case
      move < 3 : move + 1;
      TRUE : 0;
    esac;

-- objetivos separados para cada cenário
DEFINE
  goal1 := (loc_c = 0) & (loc_a = ON_C) & (loc_b = ON_A) & (loc_d = ON_B);
  goal2 := (loc_c = 0) & (loc_a = ON_C) & (loc_b = ON_A) & (loc_d = ON_B);  -- ajustar conforme necessário
  goal3 := (loc_c = 0) & (loc_a = ON_C) & (loc_b = ON_A) & (loc_d = ON_B);  -- ajustar conforme necessário

-- especificações CTL: existe um caminho até o objetivo de cada cenário
CTLSPEC EF(goal1);
CTLSPEC EF(goal2);
CTLSPEC EF(goal3);
