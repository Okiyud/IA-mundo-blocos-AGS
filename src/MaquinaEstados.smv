-- blocks_scenarios_final.smv
-- Máquina de Estados - Mundo dos Blocos com múltiplos cenários
-- O objetivo é verificar !EF(goal), cuja falsidade gera o plano (contraexemplo)

MODULE main

CONSTANTS
  MAXLOC := 10;
  SCENARIO := 1;  -- <<< escolha o cenário: 1, 2 ou 3

VAR
  loc_a : 0..MAXLOC;
  loc_b : 0..MAXLOC;
  loc_c : 0..MAXLOC;
  loc_d : 0..MAXLOC;
  move  : 0..3;  -- código da ação escolhida

DEFINE
  SIZE_A := 1;
  SIZE_B := 1;
  SIZE_C := 2;
  SIZE_D := 2;
  TABLE_WIDTH := 7;

  ON_A := 7;
  ON_B := 8;
  ON_C := 9;
  ON_D := 10;

-- posição absoluta: se estiver sobre outro bloco, herda a posição do suporte
DEFINE
  abs_pos_a := case
    loc_a <= 6 : loc_a;
    loc_a = ON_B : abs_pos_b;
    loc_a = ON_C : abs_pos_c;
    loc_a = ON_D : abs_pos_d;
    TRUE : 0;
  esac;

  abs_pos_b := case
    loc_b <= 6 : loc_b;
    loc_b = ON_A : abs_pos_a;
    loc_b = ON_C : abs_pos_c;
    loc_b = ON_D : abs_pos_d;
    TRUE : 0;
  esac;

  abs_pos_c := case
    loc_c <= 6 : loc_c;
    loc_c = ON_A : abs_pos_a;
    loc_c = ON_B : abs_pos_b;
    loc_c = ON_D : abs_pos_d;
    TRUE : 0;
  esac;

  abs_pos_d := case
    loc_d <= 6 : loc_d;
    loc_d = ON_A : abs_pos_a;
    loc_d = ON_B : abs_pos_b;
    loc_d = ON_C : abs_pos_c;
    TRUE : 0;
  esac;

-- um bloco está "clear" se nenhum outro está sobre ele
DEFINE
  clear_a := !(loc_b = ON_A | loc_c = ON_A | loc_d = ON_A);
  clear_b := !(loc_a = ON_B | loc_c = ON_B | loc_d = ON_B);
  clear_c := !(loc_a = ON_C | loc_b = ON_C | loc_d = ON_C);
  clear_d := !(loc_a = ON_D | loc_b = ON_D | loc_c = ON_D);

-- pré-condições simplificadas
DEFINE
  can_move_a_on_c := clear_a & clear_c & (SIZE_A <= SIZE_C);
  can_move_b_on_a := clear_b & clear_a & (SIZE_B <= SIZE_A);
  can_move_d_on_b := clear_d & clear_b & (SIZE_D <= SIZE_B);

-- inicialização dos blocos conforme o cenário
ASSIGN
  init(loc_a) :=
    case
      SCENARIO = 1 : 3;  -- situação 1
      SCENARIO = 2 : 0;  -- situação 2
      SCENARIO = 3 : 3;  -- situação 3
      TRUE : 0;
    esac;

  init(loc_b) :=
    case
      SCENARIO = 1 : 4;
      SCENARIO = 2 : 1;
      SCENARIO = 3 : 4;
      TRUE : 0;
    esac;

  init(loc_c) :=
    case
      SCENARIO = 1 : 0;
      SCENARIO = 2 : 2;
      SCENARIO = 3 : 0;
      TRUE : 0;
    esac;

  init(loc_d) :=
    case
      SCENARIO = 1 : 5;
      SCENARIO = 2 : 3;
      SCENARIO = 3 : 5;
      TRUE : 0;
    esac;

  init(move) := 0;

-- transições de estado
ASSIGN
  next(loc_a) :=
    case
      move = 1 & can_move_a_on_c : ON_C;
      TRUE : loc_a;
    esac;

  next(loc_b) :=
    case
      move = 2 & can_move_b_on_a : ON_A;
      TRUE : loc_b;
    esac;

  next(loc_c) := loc_c;

  next(loc_d) :=
    case
      move = 3 & can_move_d_on_b : ON_B;
      TRUE : loc_d;
    esac;

  next(move) :=
    case
      move < 3 : move + 1;
      TRUE : 0;
    esac;

-- objetivos (traduzidos dos goal_state_n do Prolog)
DEFINE
  -- Situação 1: torre c–a–b–d
  goal1 := (loc_c = 0) & (loc_a = ON_C) & (loc_b = ON_A) & (loc_d = ON_B);

  -- Situação 2: torre c–a–b–d (mesmo objetivo, mesa diferente)
  goal2 := (loc_c = 0) & (loc_a = ON_C) & (loc_b = ON_A) & (loc_d = ON_B);

  -- Situação 3: torre c–d–a–b
  goal3 := (loc_c = 0) & (loc_d = ON_C) & (loc_a = ON_D) & (loc_b = ON_A);

-- Especificações CTL
-- NOTA: verificamos !EF(goalX)
--       Se for FALSA => existe plano (contraexemplo = sequência de ações)

CTLSPEC !EF(goal1)
CTLSPEC !EF(goal2)
CTLSPEC !EF(goal3)

-- FAIRNESS TRUE para garantir geração de traço completo
FAIRNESS TRUE
